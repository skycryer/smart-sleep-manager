Menu="Settings"
Title="Smart Sleep Manager"
Icon="smartsleep.png"
---
<?PHP
/* Smart Sleep Manager Plugin for Unraid
 * Automated sleep management with configurable conditions
 * Based on sleepy.sh with web UI configuration
 */
?>
<?
$plugin = 'smart.sleep.manager';
$scripts = "$docroot/plugins/$plugin/scripts";
$config = "/boot/config/plugins/$plugin/$plugin.cfg";
$cfg = parse_plugin_cfg($plugin);

// Get available disks
exec("lsblk -d -n -o NAME,TYPE | grep disk | awk '{print \$1}'", $all_disks);

// Get array disk information from Unraid
$array_disks = [];
$other_disks = [];

// Try to get array disks from Unraid's disk assignments
if (file_exists('/var/local/emhttp/disks.ini')) {
    $disks_ini = parse_ini_file('/var/local/emhttp/disks.ini', true);
    foreach ($disks_ini as $section => $data) {
        if (isset($data['device']) && isset($data['type'])) {
            $device = basename($data['device']); // Get just the device name (e.g., sdb)
            if ($data['type'] === 'Data' || $data['type'] === 'Parity') {
                $array_disks[] = $device;
            }
        }
    }
}

// If disks.ini method didn't work, fall back to mdstat parsing
if (empty($array_disks)) {
    exec("cat /proc/mdstat | grep -E '^md[0-9]+' | awk '{print \$1}'", $array_info);
    
    function is_array_disk($disk, $array_info) {
        foreach ($array_info as $md) {
            $details = exec("cat /proc/mdstat | grep -A1 '$md' | tail -1");
            if (strpos($details, $disk) !== false) {
                return true;
            }
        }
        return false;
    }
    
    // Separate array disks from others using mdstat
    foreach ($all_disks as $disk) {
        if (is_array_disk($disk, $array_info)) {
            $array_disks[] = $disk;
        } else {
            $other_disks[] = $disk;
        }
    }
} else {
    // Use the disks.ini results, put remaining disks in other_disks
    foreach ($all_disks as $disk) {
        if (!in_array($disk, $array_disks)) {
            $other_disks[] = $disk;
        }
    }
}

// If still no array disks found, use all disks as potential array disks
if (empty($array_disks)) {
    $array_disks = $all_disks;
    $other_disks = $all_disks; // Show same disks in both lists
}

// For the dropdowns, we want ALL disks to be available in BOTH lists
// This allows users to select any disk for monitoring or ignoring
$all_available_disks = $all_disks;

// Debug: Let's see what we have in config
// error_log("DEBUG: array_disks config = " . ($cfg['array_disks'] ?? 'not set'));
// error_log("DEBUG: ignore_disks config = " . ($cfg['ignore_disks'] ?? 'not set'));

// Convert config strings to arrays for easier checking
$selected_monitor_disks = empty($cfg['monitor_disks']) ? [] : explode(' ', trim($cfg['monitor_disks']));

// For backwards compatibility, if old array_disks config exists, use it
if (empty($cfg['monitor_disks']) && !empty($cfg['array_disks'])) {
    $selected_monitor_disks = explode(' ', trim($cfg['array_disks']));
}

// Get network interfaces
exec("ip link show | grep -E '^[0-9]+:' | awk -F': ' '{print \$2}' | grep -v lo", $network_interfaces);
?>

<script>
function validateForm(form) {
    // Validate idle time
    var idleTime = parseInt(form.idle_time_minutes.value);
    if (isNaN(idleTime) || idleTime < 1 || idleTime > 1440) {
        alert('Idle time must be between 1 and 1440 minutes');
        return false;
    }
    
    // Validate network threshold
    var threshold = parseInt(form.network_threshold.value);
    if (isNaN(threshold) || threshold < 0) {
        alert('Network threshold must be a positive number');
        return false;
    }
    
    // Prepare monitor disks selection
    var monitorDisks = [];
    for (var i=0; item=form.monitor_disks.options[i]; i++) {
        if (item.selected) {
            monitorDisks.push(item.value);
        }
    }
    form.monitor_disks_list.value = monitorDisks.join(' ');
    
    return true;
}

function testSystem() {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', '/plugins/smart.sleep.manager/include/debug_system.php', true);
    xhr.onreadystatechange = function() {
        if (xhr.readyState === 4) {
            console.log('System Debug Status:', xhr.status);
            console.log('System Debug Response:', xhr.responseText);
            if (xhr.status === 200) {
                try {
                    var response = JSON.parse(xhr.responseText);
                    if (response.success) {
                        console.log('Debug Info:', response.debug_info);
                        alert('‚úÖ System Debug successful!\n\nCheck browser console (F12) for detailed information.\n\nPHP Version: ' + response.debug_info.php_version + '\nPlugin Dir: ' + (response.debug_info.plugin_dir_exists ? 'EXISTS' : 'MISSING'));
                    } else {
                        alert('‚ùå System Debug failed: ' + response.error);
                    }
                } catch (e) {
                    alert('‚ùå System Debug failed: Invalid JSON\n\nResponse: ' + xhr.responseText.substring(0, 500));
                }
            } else {
                alert('‚ùå System Debug failed: HTTP ' + xhr.status + '\n\nThis means PHP is not running or the file is not accessible.');
            }
        }
    };
    xhr.send();
}

function testPHP() {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', '/plugins/smart.sleep.manager/include/test_basic.php', true);
    xhr.onreadystatechange = function() {
        if (xhr.readyState === 4) {
            console.log('PHP Test Status:', xhr.status);
            console.log('PHP Test Response:', xhr.responseText);
            if (xhr.status === 200) {
                try {
                    var response = JSON.parse(xhr.responseText);
                    alert('‚úÖ PHP Test successful!\nPHP Version: ' + response.php_version + '\nTime: ' + response.timestamp);
                } catch (e) {
                    alert('‚ùå PHP Test failed: Invalid JSON\n\nResponse: ' + xhr.responseText.substring(0, 200));
                }
            } else {
                alert('‚ùå PHP Test failed: HTTP ' + xhr.status);
            }
        }
    };
    xhr.send();
}

function testTelegram(form) {
    if (!form.telegram_bot_token.value || !form.telegram_chat_id.value) {
        alert('Please enter both Bot Token and Chat ID to test Telegram');
        return;
    }
    
    // Show loading message
    var button = document.querySelector('input[value="Test Telegram"]');
    var originalValue = button.value;
    button.value = 'Sending...';
    button.disabled = true;
    
    var xhr = new XMLHttpRequest();
    xhr.open('POST', '/plugins/smart.sleep.manager/include/test_telegram.php', true);
    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    xhr.onreadystatechange = function() {
        if (xhr.readyState === 4) {
            // Reset button
            button.value = originalValue;
            button.disabled = false;
            
            if (xhr.status === 200) {
                console.log('Raw response:', xhr.responseText);
                try {
                    var response = JSON.parse(xhr.responseText);
                    if (response.success) {
                        alert('‚úÖ Telegram test successful! Message sent.');
                    } else {
                        alert('‚ùå Telegram test failed: ' + response.error);
                    }
                } catch (e) {
                    console.error('JSON parse error:', e);
                    console.error('Response text:', xhr.responseText);
                    alert('‚ùå Telegram test failed: Invalid response from server\n\nResponse: ' + xhr.responseText.substring(0, 200));
                }
            } else {
                alert('‚ùå Network error during Telegram test (HTTP ' + xhr.status + ')');
            }
        }
    };
    xhr.send('bot_token=' + encodeURIComponent(form.telegram_bot_token.value) + 
             '&chat_id=' + encodeURIComponent(form.telegram_chat_id.value));
}

function runSleepCheck() {
    if (confirm('Run sleep check now? This will execute the sleep logic once manually.')) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', '/plugins/<?=$plugin?>/scripts/smart_sleep.sh', true);
        xhr.onreadystatechange = function() {
            if (xhr.readyState === 4) {
                alert('Sleep check executed. Check the log file for details.');
            }
        };
        xhr.send();
    }
}

$(function() {
    // Check if dropdownchecklist plugin is available
    if ($.fn.dropdownchecklist) {
        try {
            // Initialize dropdown
            $("#monitor_disks_select").dropdownchecklist({emptyText:'None', width:200, explicitClose:'...close'});
            
            // Refresh after a short delay
            setTimeout(function() {
                try {
                    $("#monitor_disks_select").dropdownchecklist("refresh");
                } catch(e) {
                    console.log('Dropdown refresh failed:', e);
                }
            }, 500);
        } catch(e) {
            console.log('Dropdownchecklist plugin initialization failed:', e);
        }
    } else {
        console.log('Dropdownchecklist plugin not available, using standard selects');
    }
});
</script>

<form markdown="1" name="smart_sleep_settings" method="POST" action="/update.php" target="progressFrame" onsubmit="return validateForm(this)">
<input type="hidden" name="#file" value="<?=$plugin?>/<?=$plugin?>.cfg">
<input type="hidden" name="#include" value="plugins/<?=$plugin?>/include/update.sleep.php">
<input type="hidden" name="monitor_disks_list" value="">

<div style="width: 100%; margin-bottom: 20px;">
    <h2>üåô Smart Sleep Manager Configuration</h2>
    <p>Automated sleep management for your Unraid server with intelligent monitoring and Telegram notifications.</p>
</div>

## ‚öôÔ∏è Basic Settings

_(Enable Smart Sleep)_:
: <select name="enabled">
  <?=mk_option($cfg['enabled'], "true", "Enabled")?>
  <?=mk_option($cfg['enabled'], "false", "Disabled")?>
  </select>

> Enable or disable the Smart Sleep Manager. When disabled, the cron job will not perform any sleep checks.

_(Idle Time Before Sleep)_ (minutes):
: <input type="number" name="idle_time_minutes" min="1" max="1440" value="<?=$cfg['idle_time_minutes']?:15?>" class="narrow">

> Time in minutes that all conditions must be met before the system goes to sleep. Default: 15 minutes.

_(Sleep Method)_:
: <select name="sleep_method">
  <?=mk_option($cfg['sleep_method'], "dynamix_s3", "Dynamix S3 Sleep (Recommended)")?>
  <?=mk_option($cfg['sleep_method'], "systemctl_suspend", "systemctl suspend")?>
  </select>

> Sleep method to use. Dynamix S3 is recommended as it includes proper WOL setup and post-wake activities.

## üíæ Disk Monitoring

_(Disks to Monitor)_:
: <select id="monitor_disks_select" name="monitor_disks" multiple style="width: 200px; height: 120px;">
  <?foreach ($all_available_disks as $disk):?>
  <option value="<?=$disk?>"<?=in_array($disk, $selected_monitor_disks) ? ' selected' : ''?>><?=$disk?></option>
  <?endforeach;?>
  </select>

> Select which disks must be in standby before sleep is allowed. All other disks will be ignored and won't prevent sleep.

## üåê Network Monitoring

_(Monitor Network Activity)_:
: <select name="network_monitoring">
  <?=mk_option($cfg['network_monitoring'], "true", "Enabled")?>
  <?=mk_option($cfg['network_monitoring'], "false", "Disabled")?>
  </select>

> Enable network activity monitoring. High network traffic will prevent sleep.

_(Network Interface)_:
: <select name="network_interface">
  <?foreach ($network_interfaces as $interface):?>
  <?=mk_option($cfg['network_interface'], trim($interface), trim($interface))?>
  <?endforeach;?>
  </select>

> Network interface to monitor for activity (usually eth0 or br0).

_(Network Threshold)_ (Bytes/second):
: <input type="number" name="network_threshold" min="0" value="<?=$cfg['network_threshold']?:102400?>" class="narrow">

> Network traffic threshold in bytes per second. Traffic above this level will prevent sleep. Default: 102400 (100 KB/s).

## üì± Telegram Notifications

_(Enable Telegram)_:
: <select name="telegram_enabled">
  <?=mk_option($cfg['telegram_enabled'], "true", "Enabled")?>
  <?=mk_option($cfg['telegram_enabled'], "false", "Disabled")?>
  </select>

> Enable Telegram bot notifications for sleep events.

_(Bot Token)_:
: <input type="text" name="telegram_bot_token" value="<?=$cfg['telegram_bot_token']?>" placeholder="123456789:ABCdefGHIjklMNOpqrsTUVwxyz" style="width: 300px;">

> Telegram Bot Token from @BotFather. Format: 123456789:ABCdefGHIjklMNOpqrsTUVwxyz

_(Chat ID)_:
: <input type="text" name="telegram_chat_id" value="<?=$cfg['telegram_chat_id']?>" placeholder="Your Chat ID" class="narrow">

> Your Telegram Chat ID. Send a message to your bot, then visit: https://api.telegram.org/botTOKEN/getUpdates

_(System Debug)_:
: <input type="button" value="System Debug" onclick="testSystem()">

> Comprehensive system analysis to diagnose Unraid issues. Check browser console (F12) for detailed output.

_(Test PHP)_:
: <input type="button" value="Test PHP" onclick="testPHP()">

> Test basic PHP functionality first before testing Telegram.

_(Test Telegram)_:
: <input type="button" value="Test Telegram" onclick="testTelegram(this.form)">

> Send a test message to verify Telegram configuration.

### üîî Notification Types

_(Notify on Standby Timer Start)_:
: <select name="telegram_notify_standby">
  <?=mk_option($cfg['telegram_notify_standby'], "true", "Enabled")?>
  <?=mk_option($cfg['telegram_notify_standby'], "false", "Disabled")?>
  </select>

_(Notify on Sleep)_:
: <select name="telegram_notify_sleep">
  <?=mk_option($cfg['telegram_notify_sleep'], "true", "Enabled")?>
  <?=mk_option($cfg['telegram_notify_sleep'], "false", "Disabled")?>
  </select>

_(Notify on Sleep Blocked)_:
: <select name="telegram_notify_blocked">
  <?=mk_option($cfg['telegram_notify_blocked'], "false", "Disabled")?>
  <?=mk_option($cfg['telegram_notify_blocked'], "true", "Enabled")?>
  </select>

> Warning: Sleep blocked notifications can be frequent and may spam your Telegram.

## üîß Advanced Settings

_(Wake-on-LAN Options)_:
: <input type="text" name="wol_options" value="<?=$cfg['wol_options']?:'g'?>" class="narrow" placeholder="g">

> WOL options for ethtool (usually 'g' for MagicPacket). Leave default unless you have specific requirements.

_(Restart Samba after Wake)_:
: <select name="restart_samba">
  <?=mk_option($cfg['restart_samba'], "true", "Enabled")?>
  <?=mk_option($cfg['restart_samba'], "false", "Disabled")?>
  </select>

> Restart Samba service after wake-up. Recommended to ensure SMB shares work properly.

_(Force Gigabit after Wake)_:
: <select name="force_gigabit">
  <?=mk_option($cfg['force_gigabit'], "false", "Disabled")?>
  <?=mk_option($cfg['force_gigabit'], "true", "Enabled")?>
  </select>

> Force gigabit speed after wake-up. Only enable if you have network issues after wake.

_(DHCP Renewal after Wake)_:
: <select name="dhcp_renewal">
  <?=mk_option($cfg['dhcp_renewal'], "false", "Disabled")?>
  <?=mk_option($cfg['dhcp_renewal'], "true", "Enabled")?>
  </select>

> Renew DHCP lease after wake-up. Only enable if using DHCP and having network issues.

## üìã Monitoring & Testing

_(Manual Sleep Check)_:
: <input type="button" value="Run Sleep Check Now" onclick="runSleepCheck()">

> Manually execute the sleep check logic once. Useful for testing configuration.

_(Log File Location)_:
: `/tmp/smart-sleep.log`

> View the log file to monitor Smart Sleep Manager activity and troubleshoot issues.

_(Cron Schedule)_:
: <input type="text" name="cron_schedule" value="<?=$cfg['cron_schedule']?:'*/5 * * * *'?>" style="width: 150px;" placeholder="*/5 * * * *">

> Cron schedule for automated sleep checks. Default: */5 * * * * (every 5 minutes). Examples: */1 * * * * (every minute), */15 * * * * (every 15 minutes)

&nbsp;
: <input type="submit" name="#apply" value="Apply"><input type="button" value="Done" onclick="done()">

</form>
