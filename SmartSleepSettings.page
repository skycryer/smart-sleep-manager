Menu="Settings"
Title="Smart Sleep Manager"
Icon="smartsleep.png"
---
<?PHP
/* Smart Sleep Manager Plugin for Unraid
 * Automated sleep management with configurable conditions
 * Based on sleepy.sh with web UI configuration
 */
?>
<?
$plugin = 'smart.sleep.manager';
$scripts = "$docroot/p## üìä MQTT Monitoring

_(Enable MQTT)_:
: <select name="mqtt_enabled">
  <?=mk_option($cfg['mqtt_enabled'], "true", "Enabled")?>
  <?=mk_option($cfg['mqtt_enabled'], "false", "Disabled")?>
  </select>

> Enable MQTT publishing of sleep status and system sensors. Perfect for Home Assistant integration.

> **‚ö†Ô∏è MQTT Requirements:** MQTT functionality requires the `mosquitto-clients` package. If MQTT messages are not being sent, install it manually:
> ```bash
> # Method 1: Using slackpkg (recommended)
> slackpkg install mosquitto
> 
> # Method 2: Manual download and install
> wget https://slackware.uk/slackware/slackware64-15.0/slackware64/n/mosquitto-2.0.15-x86_64-1.txz
> installpkg mosquitto-2.0.15-x86_64-1.txz
> ```
> After installation, the "Run Sleep Check Now" button will send MQTT messages to your broker.n/scripts";
$config = "/boot/config/plugins/$plugin/$plugin.cfg";
$cfg = parse_plugin_cfg($plugin);

// Ensure MQTT configuration fields exist with defaults
$cfg['mqtt_enabled'] = $cfg['mqtt_enabled'] ?? 'false';
$cfg['mqtt_host'] = $cfg['mqtt_host'] ?? '';
$cfg['mqtt_port'] = $cfg['mqtt_port'] ?? '1883';
$cfg['mqtt_username'] = $cfg['mqtt_username'] ?? '';
$cfg['mqtt_password'] = $cfg['mqtt_password'] ?? '';
$cfg['mqtt_topic_prefix'] = $cfg['mqtt_topic_prefix'] ?? 'unraid/smart-sleep';
$cfg['mqtt_retain'] = $cfg['mqtt_retain'] ?? 'true';

// Get available disks
exec("lsblk -d -n -o NAME,TYPE | grep disk | awk '{print \$1}'", $all_disks);

// Get array disk information from Unraid
$array_disks = [];
$other_disks = [];

// Try to get array disks from Unraid's disk assignments
if (file_exists('/var/local/emhttp/disks.ini')) {
    $disks_ini = parse_ini_file('/var/local/emhttp/disks.ini', true);
    foreach ($disks_ini as $section => $data) {
        if (isset($data['device']) && isset($data['type'])) {
            $device = basename($data['device']); // Get just the device name (e.g., sdb)
            if ($data['type'] === 'Data' || $data['type'] === 'Parity') {
                $array_disks[] = $device;
            }
        }
    }
}

// If disks.ini method didn't work, fall back to mdstat parsing
if (empty($array_disks)) {
    exec("cat /proc/mdstat | grep -E '^md[0-9]+' | awk '{print \$1}'", $array_info);
    
    function is_array_disk($disk, $array_info) {
        foreach ($array_info as $md) {
            $details = exec("cat /proc/mdstat | grep -A1 '$md' | tail -1");
            if (strpos($details, $disk) !== false) {
                return true;
            }
        }
        return false;
    }
    
    // Separate array disks from others using mdstat
    foreach ($all_disks as $disk) {
        if (is_array_disk($disk, $array_info)) {
            $array_disks[] = $disk;
        } else {
            $other_disks[] = $disk;
        }
    }
} else {
    // Use the disks.ini results, put remaining disks in other_disks
    foreach ($all_disks as $disk) {
        if (!in_array($disk, $array_disks)) {
            $other_disks[] = $disk;
        }
    }
}

// If still no array disks found, use all disks as potential array disks
if (empty($array_disks)) {
    $array_disks = $all_disks;
    $other_disks = $all_disks; // Show same disks in both lists
}

// For the dropdowns, we want ALL disks to be available in BOTH lists
// This allows users to select any disk for monitoring or ignoring
$all_available_disks = $all_disks;

// Convert config strings to arrays for easier checking
$selected_monitor_disks = [];

// First, try the new monitor_disks field
if (!empty($cfg['monitor_disks'])) {
    $selected_monitor_disks = explode(' ', trim($cfg['monitor_disks']));
}
// Fallback to old array_disks field for backwards compatibility
elseif (!empty($cfg['array_disks'])) {
    $selected_monitor_disks = explode(' ', trim($cfg['array_disks']));
}
// If neither is set, default to all array disks (auto-select common disks)
else {
    $selected_monitor_disks = $array_disks;
}

// Remove empty entries
$selected_monitor_disks = array_filter($selected_monitor_disks, function($disk) {
    return !empty(trim($disk));
});

// Debug info
error_log("Smart Sleep Manager DEBUG: available disks = " . implode(', ', $all_available_disks));
error_log("Smart Sleep Manager DEBUG: selected monitor disks = " . implode(', ', $selected_monitor_disks));

// Get network interfaces
exec("ip link show | grep -E '^[0-9]+:' | awk -F': ' '{print \$2}' | grep -v lo", $network_interfaces);
?>

<script>
function validateForm(form) {
    // Validate idle time
    var idleTime = parseInt(form.idle_time_minutes.value);
    if (isNaN(idleTime) || idleTime < 1 || idleTime > 1440) {
        alert('Idle time must be between 1 and 1440 minutes');
        return false;
    }
    
    // Validate network threshold
    var networkThreshold = parseInt(form.network_threshold.value);
    if (isNaN(networkThreshold) || networkThreshold < 0) {
        alert('Network threshold must be 0 or greater');
        return false;
    }
    
    return true;
}

function runSleepCheck() {
    if (confirm('Run sleep check now? This will execute the sleep logic once manually.')) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', '/plugins/<?=$plugin?>/include/run_sleep_check.php', true);
        xhr.onreadystatechange = function() {
            if (xhr.readyState === 4) {
                if (xhr.status === 200) {
                    // Show the output in a popup or console
                    console.log('Sleep check output:', xhr.responseText);
                    alert('Sleep check executed. Output logged to browser console. Check /tmp/smart-sleep.log for details.');
                } else {
                    alert('Error executing sleep check. Status: ' + xhr.status);
                }
            }
        };
        xhr.send();
    }
}

function checkMQTTRequirements() {
    // Check if mosquitto_pub is available when MQTT is enabled
    var mqttEnabled = document.querySelector('select[name="mqtt_enabled"]').value;
    if (mqttEnabled === 'true') {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', '/plugins/<?=$plugin?>/include/check_mosquitto.php', true);
        xhr.onreadystatechange = function() {
            if (xhr.readyState === 4 && xhr.status === 200) {
                var response = xhr.responseText.trim();
                if (response === 'missing') {
                    alert('‚ö†Ô∏è Warning: mosquitto-clients package not found!\n\nMQTT messages will not be sent until you install it:\n\n1. Run: slackpkg install mosquitto\n2. Or download and install manually\n\nSee the MQTT section for detailed instructions.');
                }
            }
        };
        xhr.send();
    }
}

$(function() {
    // Check if dropdownchecklist plugin is available
    if ($.fn.dropdownchecklist) {
        try {
            // Initialize dropdown with proper settings
            $("#monitor_disks_select").dropdownchecklist({
                emptyText: 'No disks selected',
                width: 250,
                maxDropHeight: 200,
                explicitClose: '...close',
                icon: {},
                textFormatFunction: function(options) {
                    var selected = options.filter(':selected');
                    if (selected.length === 0) {
                        return 'No disks selected';
                    } else if (selected.length === 1) {
                        return '1 disk: ' + selected.first().text();
                    } else {
                        return selected.length + ' disks selected';
                    }
                }
            });
            
            // Refresh after initialization
            setTimeout(function() {
                try {
                    $("#monitor_disks_select").dropdownchecklist("refresh");
                } catch(e) {
                    console.log('Dropdown refresh failed:', e);
                }
            }, 100);
            
        } catch(e) {
            console.log('Dropdownchecklist plugin initialization failed:', e);
            // Fallback to simple tooltip
            var select = document.getElementById('monitor_disks_select');
            if (select) {
                function updateSelectDisplay() {
                    var selected = Array.from(select.selectedOptions);
                    if (selected.length === 0) {
                        select.title = 'No disks selected';
                    } else if (selected.length === 1) {
                        select.title = '1 disk selected: ' + selected[0].text;
                    } else {
                        select.title = selected.length + ' disks selected: ' + selected.map(o => o.text).join(', ');
                    }
                }
                select.addEventListener('change', updateSelectDisplay);
                updateSelectDisplay();
            }
        }
    } else {
        console.log('Dropdownchecklist plugin not available, using standard multi-select with tooltip');
        // Fallback to simple tooltip
        var select = document.getElementById('monitor_disks_select');
        if (select) {
            function updateSelectDisplay() {
                var selected = Array.from(select.selectedOptions);
                if (selected.length === 0) {
                    select.title = 'No disks selected';
                } else if (selected.length === 1) {
                    select.title = '1 disk selected: ' + selected[0].text;
                } else {
                    select.title = selected.length + ' disks selected: ' + selected.map(o => o.text).join(', ');
                }
            }
            select.addEventListener('change', updateSelectDisplay);
            updateSelectDisplay();
        }
    }
    
    // Add event listener for MQTT enabled dropdown
    $('select[name="mqtt_enabled"]').change(function() {
        checkMQTTRequirements();
    });
});
</script>

<form markdown="1" name="smart_sleep_settings" method="POST" action="/plugins/smart.sleep.manager/include/update.sleep.php" onsubmit="return validateForm(this);">
<input type="hidden" name="#redirect" value="/Settings/SmartSleepSettings">

# Smart Sleep Manager Configuration

## üîß Basic Settings

_(Enable Smart Sleep Manager)_:
: <select name="enabled">
  <?=mk_option($cfg['enabled'], "true", "Enabled")?>
  <?=mk_option($cfg['enabled'], "false", "Disabled")?>
  </select>

> Enable or disable automatic sleep management.

_(Idle Time)_ (minutes):
: <input type="number" name="idle_time_minutes" min="1" max="1440" value="<?=$cfg['idle_time_minutes']?:15?>" class="narrow">

> Minutes to wait after all disks are in standby before putting the server to sleep.

_(Sleep Method)_:
: <select name="sleep_method">
  <?=mk_option($cfg['sleep_method'], "dynamix_s3", "Dynamix S3 Sleep")?>
  <?=mk_option($cfg['sleep_method'], "systemctl_suspend", "systemctl suspend")?>
  </select>

> Sleep method to use. Dynamix S3 is recommended as it includes proper WOL setup and post-wake activities.

## üíæ Disk Monitoring

_(Disks to Monitor)_:
: <select id="monitor_disks_select" name="monitor_disks" multiple style="width: 200px; height: 120px;">
  <?foreach ($all_available_disks as $disk):?>
  <option value="<?=$disk?>"<?=in_array($disk, $selected_monitor_disks) ? ' selected' : ''?>><?=$disk?></option>
  <?endforeach;?>
  </select>

> Select which disks must be in standby before sleep is allowed. All other disks will be ignored and won't prevent sleep.

## üåê Network Monitoring

_(Monitor Network Activity)_:
: <select name="network_monitoring">
  <?=mk_option($cfg['network_monitoring'], "true", "Enabled")?>
  <?=mk_option($cfg['network_monitoring'], "false", "Disabled")?>
  </select>

> Enable network activity monitoring. High network traffic will prevent sleep.

_(Network Interface)_:
: <select name="network_interface">
  <?foreach ($network_interfaces as $interface):?>
  <?=mk_option($cfg['network_interface'], trim($interface), trim($interface))?>
  <?endforeach;?>
  </select>

> Network interface to monitor for activity (usually eth0 or br0).

_(Network Threshold)_ (Bytes/second):
: <input type="number" name="network_threshold" min="0" value="<?=$cfg['network_threshold']?:102400?>" class="narrow">

> Network traffic threshold in bytes per second. Traffic above this level will prevent sleep. Default: 102400 (100 KB/s).

## üìä MQTT Monitoring

_(Enable MQTT)_:

## ÔøΩ MQTT Monitoring

_(Enable MQTT)_:
: <select name="mqtt_enabled">
  <?=mk_option($cfg['mqtt_enabled'], "true", "Enabled")?>
  <?=mk_option($cfg['mqtt_enabled'], "false", "Disabled")?>
  </select>

> Enable MQTT publishing of sleep status and system sensors. Perfect for Home Assistant integration.

_(MQTT Host)_:
: <input type="text" name="mqtt_host" value="<?=$cfg['mqtt_host']?>" placeholder="192.168.1.100" style="width: 200px;">

> MQTT broker hostname or IP address.

_(MQTT Port)_:
: <input type="number" name="mqtt_port" min="1" max="65535" value="<?=$cfg['mqtt_port']?:1883?>" class="narrow">

> MQTT broker port. Default: 1883 (standard MQTT), 8883 (MQTT over TLS).

_(MQTT Username)_:
: <input type="text" name="mqtt_username" value="<?=$cfg['mqtt_username']?>" placeholder="optional" style="width: 200px;">

> MQTT username (leave empty if no authentication required).

_(MQTT Password)_:
: <input type="password" name="mqtt_password" value="<?=$cfg['mqtt_password']?>" placeholder="optional" style="width: 200px;">

> MQTT password (leave empty if no authentication required).

_(MQTT Topic Prefix)_:
: <input type="text" name="mqtt_topic_prefix" value="<?=$cfg['mqtt_topic_prefix']?:'unraid/smart-sleep'?>" style="width: 300px;">

> Topic prefix for all MQTT messages. Default: unraid/smart-sleep

_(Retain Messages)_:
: <select name="mqtt_retain">
  <?=mk_option($cfg['mqtt_retain'], "true", "Enabled")?>
  <?=mk_option($cfg['mqtt_retain'], "false", "Disabled")?>
  </select>

> Retain MQTT messages so last values are available after broker restart.

### üìà MQTT Sensors Published

> The following sensors are published to MQTT on each sleep check:
> - `{prefix}/status` - Current sleep manager status (standby/waiting/sleeping/blocked)
> - `{prefix}/uptime` - System uptime in seconds  
> - `{prefix}/network_rate` - Current network traffic in bytes/second
> - `{prefix}/active_disks` - Number of active (non-standby) disks
> - `{prefix}/sleep_timer` - Minutes until sleep possible
> - `{prefix}/last_check` - Timestamp of last check

## ÔøΩüîß Advanced Settings

_(Wake-on-LAN Options)_:
: <input type="text" name="wol_options" value="<?=$cfg['wol_options']?:'g'?>" class="narrow" placeholder="g">

> WOL options for ethtool (usually 'g' for MagicPacket). Leave default unless you have specific requirements.

_(Restart Samba after Wake)_:
: <select name="restart_samba">
  <?=mk_option($cfg['restart_samba'], "true", "Enabled")?>
  <?=mk_option($cfg['restart_samba'], "false", "Disabled")?>
  </select>

> Restart Samba service after wake-up. Recommended to ensure SMB shares work properly.

_(Force Gigabit after Wake)_:
: <select name="force_gigabit">
  <?=mk_option($cfg['force_gigabit'], "false", "Disabled")?>
  <?=mk_option($cfg['force_gigabit'], "true", "Enabled")?>
  </select>

> Force gigabit speed after wake-up. Only enable if you have network issues after wake.

_(DHCP Renewal after Wake)_:
: <select name="dhcp_renewal">
  <?=mk_option($cfg['dhcp_renewal'], "false", "Disabled")?>
  <?=mk_option($cfg['dhcp_renewal'], "true", "Enabled")?>
  </select>

> Renew DHCP lease after wake-up. Only enable if using DHCP and having network issues.

## üìã Monitoring & Testing

_(Manual Sleep Check)_:
: <input type="button" value="Run Sleep Check Now" onclick="runSleepCheck()">

> Manually execute the sleep check logic once. Useful for testing configuration.

_(Log File Location)_:
: `/tmp/smart-sleep.log`

> View the log file to monitor Smart Sleep Manager activity and troubleshoot issues.

_(Cron Schedule)_:
: <input type="text" name="cron_schedule" value="<?=$cfg['cron_schedule']?:'*/5 * * * *'?>" style="width: 150px;" placeholder="*/5 * * * *">

> Cron schedule for automated sleep checks. Default: */5 * * * * (every 5 minutes). Examples: */1 * * * * (every minute), */15 * * * * (every 15 minutes)

&nbsp;
: <input type="submit" name="#apply" value="Apply"><input type="button" value="Done" onclick="done()">

</form>